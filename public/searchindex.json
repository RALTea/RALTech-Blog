[{"section":"Blog","slug":"/blog/august-6th-2025---getting-started-with-monads/","title":"August 6th, 2025 - Getting started with monads","description":"","date":"August 6, 2025","image":null,"imageSM":null,"searchKeyword":"","categories":"","tags":"programming, diary, journal","content":"If you\u0026rsquo;ve written any amount of TypeScript, you probably have written code similar to this:\nfunction getUsersZipCode(id: number): string | null { const user = users.find(u =\u0026gt; u.id === id); if (!user) { return null; } if (!user.profile || !user.profile.address) { return null; } return user.profile.address.zipCode || null; } This works, and it\u0026rsquo;s definitely flatter than a bunch of nested ifs. But it\u0026rsquo;s still noisy. Each step is a defensive check, a guard clause that interrupts the flow. The core logic is obscured by boilerplate.\nIn today\u0026rsquo;s lesson on my journey to learn Functional Programming (FP), I learnt about the concept of Monads, that might fix this issue I always had. The challenge was to build a Maybe monad from scratch.\nPart 1: Wait, Why Do I Need flatMap? My first task was to create a Maybe type, which could be either a Just(value) or a Nothing(). I decided to use simple factory functions instead of classes to keep things feeling functional. After some back-and-forth on getting the TypeScript generics right, I had my building blocks:\n// A function that returns a value inside a box const Just = \u0026lt;T\u0026gt;(value: T): Maybe\u0026lt;T\u0026gt; =\u0026gt; ({ ... }); // A function that returns an empty box const Nothing = \u0026lt;T\u0026gt;(): Maybe\u0026lt;T\u0026gt; =\u0026gt; ({ ... }); With these, I wrote my first function, findUser, which returned a Maybe\u0026lt;User\u0026gt;.\nTo apply concepts I learnt about earlier in my FP course, I curried the function to make my functions pure. This part was rather straightforward.\n// findUser is curried: it takes the user list, and returns a new function // that is waiting for an id. const findUser = (users: User[]) =\u0026gt; (id: number): Maybe\u0026lt;User\u0026gt; =\u0026gt; { const user = users.find((u) =\u0026gt; u.id === id) // A helper to convert a null/undefined value into a Maybe return fromNullable(user); } But then came getStreetName. My first attempt was to just use .map() to access the nested properties. This felt intuitive, but it was wrong. I ended up with a Just containing undefined, which wasn\u0026rsquo;t what I wanted at all. A missing property should result in Nothing.\n// The wrong way, using map for a fallible operation const getStreetName_wrong = (user: User): Maybe\u0026lt;string\u0026gt; =\u0026gt; { // Typing error: returning Maybe\u0026lt;string | undefined\u0026gt; instead of Maybe\u0026lt;string\u0026gt; return Just(user) .map(u =\u0026gt; u.profile) // This gives Maybe\u0026lt;Profile | undefined\u0026gt; .map(p =\u0026gt; p?.address) // This gives Maybe\u0026lt;Address | undefined\u0026gt; .map(a =\u0026gt; a?.street); // This gives Maybe\u0026lt;string | undefined\u0026gt; } // When called on a user with no profile, this returns Just(undefined), NOT Nothing()! This was my first mistake.\nThe function I was passing to map was user =\u0026gt; user.profile. This action could fail (i.e., return undefined). A map is for transformations that are guaranteed to succeed. I needed something else.\n\u0026ldquo;Oh,\u0026rdquo; I thought, \u0026ldquo;so that\u0026rsquo;s where flatMap comes in.\u0026rdquo;\nflatMap is for chaining operations that might fail. It expects a function that returns not a plain value, but another Maybe. This lets you build a pipeline where each step can safely fail without breaking the whole chain.\nThis is where the fromNullable helper comes in. Instead of writing value ? Just(value) : Nothing() over and over, I could create a reusable function that does exactly that. It takes a value that could be T | null | undefined and safely wraps it in a Maybe\u0026lt;T\u0026gt;.\nconst fromNullable = \u0026lt;T\u0026gt;(value: T | null | undefined): Maybe\u0026lt;T\u0026gt; =\u0026gt; { if (value === null || value === undefined) { return Nothing(); } return Just(value); } This little utility is the key to making the pipeline clean. It encapsulates the null-checking logic, so my main functions can focus on the business logic.\nMy getStreetName function evolved from a clunky one-liner into this clean, readable pipeline:\nconst getStreetName = (user: User): Maybe\u0026lt;string\u0026gt; =\u0026gt; { return Just(user) .flatMap(user =\u0026gt; fromNullable(user.profile)) .flatMap(profile =\u0026gt; fromNullable(profile.address)) .flatMap(address =\u0026gt; fromNullable(address.street)) } Suddenly, it all made sense. But the biggest breakthrough was yet to come. The next thing I did not fully grasp yet was \u0026ldquo;Do I have to handle the Just/Nothing case inside my flatMap?\u0026rdquo;\nThe answer was no. The logic is inside the implementation of flatMap itself. I realized:\n\u0026ldquo;If findUser returns Nothing(), then the whole chain returns Nothing(), because calling flatMap on a Nothing() object returns directly Nothing(). If the user is found, the chain applies the functions.\u0026rdquo;\nThe Nothing object acts as a short-circuit. The moment it appears, the pipeline stops and just passes the Nothing down to the end. No more defensive ifs. The type system was doing the work for me.\nPart 2: Actual use of Monads with fp-ts After building it myself, using the industry-standard fp-ts library felt very straightforward. The names were different (Option instead of Maybe, chain instead of flatMap), but the concepts were identical.\nI rewrote my functions, but this time with a focus on making them as clean and reusable as possible. I\u0026rsquo;m really proud of my final code. I had a reusable getAddress helper, and my getStreetName and getZipCode functions became simple, declarative pipelines.\n// The final, elegant pipeline const street = pipe( findUser(users)(1), // Start with a Maybe\u0026lt;User\u0026gt; chain(getStreetName), // Chain it with a function that returns Maybe\u0026lt;string\u0026gt; getOrElse(() =\u0026gt; \u0026#34;No street\u0026#34;) // Exit the Maybe world with a default value ); Looking at that pipe, I finally understood. The monad isn\u0026rsquo;t as scary as it sounds. It\u0026rsquo;s a way to wrap up the messy logic of null-checking into a clean, reusable, and safe container. It turns a screen full of guard clauses into a straight, elegant pipeline. And I have to say, it feels pretty great.\nFinal Code import * as O from \u0026#34;fp-ts/Option\u0026#34;; import { pipe } from \u0026#34;fp-ts/function\u0026#34;; // --- Sample Data --- type User = { id: number; name: string; profile?: { address?: { street?: string; zipCode?: string; } } }; const users: User[] = [ { id: 1, name: \u0026#39;Alice\u0026#39;, profile: { address: { street: \u0026#39;123 Main St\u0026#39;, zipCode: \u0026#39;10001\u0026#39; } } }, { id: 2, name: \u0026#39;Bob\u0026#39;, profile: {} }, { id: 3, name: \u0026#39;Charlie\u0026#39; } ]; // --- FP Functions --- const findUser = (users: User[]) =\u0026gt; (id: number): O.Option\u0026lt;User\u0026gt; =\u0026gt; { return O.fromNullable(users.find(user =\u0026gt; user.id === id)); } const getAddress = (user: User): O.Option\u0026lt;{ street?: string; zipCode?: string; }\u0026gt; =\u0026gt; { return pipe( O.fromNullable(user.profile), O.chain(profile =\u0026gt; O.fromNullable(profile.address)), ) } const getStreetName = (user: User): O.Option\u0026lt;string\u0026gt; =\u0026gt; { return pipe( getAddress(user), O.chain(address =\u0026gt; O.fromNullable(address.street)), ) } const getZipCode = (user: User): O.Option\u0026lt;string\u0026gt; =\u0026gt; { return pipe( getAddress(user), O.chain(address =\u0026gt; O.fromNullable(address.zipCode)), ); } // --- Execution --- const findUserInDb = findUser(users); // Create a specific findUser function for our db // Find street for User 1 const street = pipe( findUserInDb(1), O.chain(getStreetName), O.getOrElse(() =\u0026gt; \u0026#34;No street found\u0026#34;) ); // Find zip for User 2 (will fail) const zipCode = pipe( findUserInDb(2), O.chain(getZipCode), O.getOrElse(() =\u0026gt; \u0026#34;No zip code found\u0026#34;) ) console.log(`User 1\u0026#39;s street: ${street}`); console.log(`User 2\u0026#39;s zip code: ${zipCode}`); "},{"section":"Blog","slug":"/blog/july-28th-2025---starting-my-journey-into-functional-programming/","title":"July 28th, 2025 - Starting My Journey into Functional Programming","description":"","date":"July 28, 2025","image":null,"imageSM":null,"searchKeyword":"","categories":"","tags":"programming, #diary, journal","content":"Why starting learning FP ? One of the main issues I encounter when building apps is the amount of small bugs that I create. No matter how much I try to test my apps, when I finally showcase my projects, I always face new bugs that I never saw before. Even behaviors that I know I tested start breaking again, and this perpetual regression is really bothering me, even if in the last few years, my apps tend to be more robust and less filled with bugs.\nIt feels like I\u0026rsquo;m playing a game of whack-a-mole. I\u0026rsquo;ll fix a bug in the user profile section, and suddenly the payment processing logic, which I haven\u0026rsquo;t touched in weeks, starts acting up. How? It\u0026rsquo;s that spooky \u0026ldquo;action at a distance\u0026rdquo; that drives me crazy. A change in one part of the codebase inexplicably affects a completely different, seemingly unrelated part. My code feels fragile, like a house of cards.\nThe very basics Today, I spent a couple of hours reading about Functional Programming (FP). It wasn\u0026rsquo;t the first time, but this time something clicked. The core ideas—immutability and pure functions—feel like a direct answer to my problems.\nThe concept of immutability means data doesn\u0026rsquo;t change after it\u0026rsquo;s created. If I need to modify something, I create a new copy with the changes. This sounds like it could eliminate that whole class of bugs where data gets unexpectedly changed by some other part of the program.\nAnother main concept of functional programming is pure functions. For a given input, they always return the same output and have no \u0026ldquo;side effects\u0026rdquo; (like modifying a global variable or writing to a database). This means they are predictable. Utterly, beautifully predictable. You can test them in a vacuum, and if they work, they\u0026rsquo;ll always work the same way.\nToday\u0026rsquo;s conclusion This honestly feels like the way to go. It’s not just about getting the code to work. I’m done looking like a noob when I put my tears and blood in a project. I really want to build apps that don\u0026rsquo;t just work for now, but are actually tough and don\u0026rsquo;t fall apart easily. So, this is it, day one. Wish me luck!\n"},{"section":"Blog","slug":"/blog/receipt-tracker-project/","title":"Receipt Tracker Project","description":"","date":"July 20, 2025","image":null,"imageSM":null,"searchKeyword":"","categories":"","tags":"PersonalProject","content":"Introducing Receipt Tracker: Your Smart Shopping Companion In our fast-paced lives, keeping track of personal finances and optimizing everyday spending can be a challenge. Receipts pile up, details fade, and the opportunity to make smarter purchasing decisions often slips away. That\u0026rsquo;s precisely the problem Receipt Tracker aims to solve.\nWhy I Built This: A Personal Journey to Smarter Spending Like many, I found myself constantly wondering: \u0026ldquo;Where did I buy that?\u0026rdquo;, \u0026ldquo;How much did I pay for this last time?\u0026rdquo;, or \u0026ldquo;Am I really getting the best deal on my groceries?\u0026rdquo; Manually sifting through paper receipts or trying to recall past purchases was tedious and inefficient. I envisioned a tool that could effortlessly capture all my shopping data, make it searchable, and provide actionable insights.\nReceipt Tracker was born from this desire for a more intelligent, automated way to manage my shopping history. It\u0026rsquo;s not just about digitizing receipts; it\u0026rsquo;s about transforming raw data into valuable information that empowers better financial decisions.\nKey Features: Bringing Your Shopping Data to Life Receipt Tracker is designed with simplicity and power in mind, offering a suite of features that make managing your purchases a breeze:\nEffortless Receipt Scanning with AI: Forget manual data entry. Simply snap a picture of your receipt, and our intelligent OCR (Optical Character Recognition) powered by advanced AI models automatically extracts crucial information like the store name, purchase date, total amount, and every individual item with its quantity and price. It\u0026rsquo;s fast, accurate, and saves you time.\nCentralized Purchase History: All your scanned receipts are stored in one secure, easily accessible place. No more lost or faded paper slips. You can quickly browse your entire shopping history at a glance.\nProduct-Level Insights: Dive deep into your spending habits. Receipt Tracker doesn\u0026rsquo;t just show you receipt totals; it breaks down your purchases by individual product. Track how much you\u0026rsquo;ve paid for your favorite items over time, identify price fluctuations, and see which brands you buy most frequently.\nSmart Store Management: The application intelligently identifies and manages store information. You can view all the places you\u0026rsquo;ve shopped, and even merge duplicate store entries to keep your data clean and organized.\nThe Future of Smart Shopping: Beyond Tracking While Receipt Tracker already offers powerful capabilities, my vision extends far beyond simple data capture. The rich dataset of your past purchases opens up exciting possibilities for truly intelligent shopping:\nIntelligent Shopping List Creation: Imagine a shopping list that practically writes itself. Based on your past purchase patterns, Receipt Tracker could suggest items you\u0026rsquo;re likely to need, remind you of recurring purchases, and even group them by store aisle for maximum efficiency.\nPersonalized Shop Recommendations: With historical price data for individual products across different stores, Receipt Tracker could become your ultimate shopping advisor. Before you head out, the app could analyze your shopping list and recommend the best store(s) to visit to get all your items at the lowest collective price, saving you money and time.\nJoin the Journey Receipt Tracker is a personal project driven by the goal of making everyday financial management simpler and smarter. It\u0026rsquo;s continuously evolving, and I\u0026rsquo;m excited to share its progress and future developments. Stay tuned for more updates as we build the ultimate smart shopping companion!\n"},{"section":"Blog","slug":"/blog/easily-deploy-your-apps-with-coolify/","title":"Easily Deploy Your Apps with Coolify","description":"Learn about coolify, and try it setting up a minecraft server","date":"May 22, 2025","image":null,"imageSM":null,"searchKeyword":"","categories":"","tags":"deployment","content":"Hey there! If you\u0026rsquo;re a developer, a small business owner, or just someone who loves building cool stuff, you know that feeling when your app is finally ready. Awesome, right? But then comes the tricky part: deployment. For a lot of us, that\u0026rsquo;s where the fun can turn into a major headache. Cloud hosting platforms promise to make things easy, but they often hit you with tricky learning curves, bills that keep climbing, and that annoying feeling that you\u0026rsquo;re not really in charge of your own stuff.\nAre you totally over complicated deployment steps, crazy high hosting costs, or just struggling to get your apps live without a fuss? What if you could get that super smooth, modern deployment experience, but with all the control and budget-friendliness of hosting things on your own server?\nWell, say hello to Coolify – an open-source solution that you can host yourself, designed specifically to make deploying your apps, databases, and services ridiculously easy, even if you\u0026rsquo;re just starting out!\nWhen I first used Coolify, I was really confused with how little steps you have to do before having a setup up and running. Before showing you how to use it, let\u0026rsquo;s see what it can do for you, and if you want to use it or not.\nSo, What Exactly IS Coolify? At its core, Coolify is an open-source, self-hostable alternative to those big Platform-as-a-Service (PaaS) companies. Picture this: you get your very own cloud management dashboard that you set up and run right on your own server. Instead of paying some big company to handle your infrastructure and deploy your apps, Coolify puts the power back in your hands. You get to do it yourself, on hardware you totally control!\nIt\u0026rsquo;s built to simplify all those tricky bits that usually come with self-hosting. You just need to provide the server – maybe a super affordable Virtual Private Server (VPS) from places like Hetzner or DigitalOcean, a powerful machine you own, a tiny Raspberry Pi, or even an old laptop you\u0026rsquo;ve got lying around. Coolify then gives you this awesome, easy-to-use interface and all the automation you need to effortlessly deploy and manage your digital projects.\nHow Coolify Works Its Magic for Super Easy Deployment The real genius of Coolify is how it takes all the confusing technical stuff about server operations and presents it in a friendly, simple web interface. Here\u0026rsquo;s how it makes deployment a breeze:\nUse your own server First things first, you\u0026rsquo;ll need a server with SSH access. This is where Coolify will live and where your apps will run. Just remember, Coolify doesn\u0026rsquo;t give you the server; it\u0026rsquo;s the powerful software that manages everything on it.\nInstallation Getting Coolify up and running on your chosen server is surprisingly simple. Usually, it\u0026rsquo;s just one command, and boom! All the necessary bits for its dashboard and deployment powers are set up.\nManage multiple VPS at once Once Coolify\u0026rsquo;s installed, you hop onto its web dashboard. From there, you securely link your server(s) to Coolify using SSH keys. This secure connection is what lets Coolify automate tasks and deploy your apps with incredible ease.\nDockerised applications Coolify uses Docker containers for all your deployments. This is a HUGE win for simplicity! It means your apps and services run in their own little isolated, portable environments. You don\u0026rsquo;t need to be a Docker wizard; Coolify handles all the tricky orchestration for you, whether you\u0026rsquo;re deploying a basic website, a complex database, or something totally custom.\nSimplified deployment and CI/CD Git Integration (Push-to-Deploy!): You can link up your Git repositories (from GitHub, GitLab, Bitbucket, Gitea, etc). Then, Coolify can automatically build and deploy your app every single time you push new code to a specific branch. No more logging into servers manually or messing with complicated scripts – just push your code, and Coolify does the rest! One-Click Services: For popular apps and databases (like WordPress, PostgreSQL, Redis, MongoDB, etc.), Coolify offers \u0026ldquo;one-click\u0026rdquo; deployment options. Seriously, you can get a fully configured service running in minutes, without any head-scratching manual setup. Custom Docker Images: Got a specific Docker image for your app? Just give Coolify the image name, and it\u0026rsquo;ll pull it down and run it for you. Easy peasy! Services can be a single component, or be rather complex, such as the self-hosted version of supabase that need 7 or 8 different containers to work correctly. With coolify, setting up supabase only takes a few click\nAutomated Essentials Coolify handles all those crucial tasks that often trip up beginners:\nFree SSL Certificates: It automatically grabs and renews those important Let\u0026rsquo;s Encrypt SSL certificates for your custom domains. That means secure HTTPS connections without you lifting a finger! Domain Management: You can easily assign your custom domain names to your deployed apps right from the Coolify dashboard. Automatic Backups: Set up automatic backups for your databases to S3-compatible storage. Hello, peace of mind! Your data is safe. Monitoring: Get basic checks on your server\u0026rsquo;s resources and how healthy your apps are, with options for alerts if something goes sideways. This super streamlined, automated approach means you spend way less time on boring server configuration and way more time on what you actually love: building and making your projects even better!\nExample: Getting a Minecraft Server Up with Coolify Let\u0026rsquo;s dive into a real-world example that truly shows off how easy Coolify is: setting up a Minecraft server! You\u0026rsquo;ll see how effortlessly you can get even complex services running.\nWhat you\u0026rsquo;ll need A server (a VPS, a dedicated machine, etc.) with Coolify already installed and ready to go. SSH access to your server (you\u0026rsquo;ll need this for the initial Coolify setup, but less so for daily deployments). A domain name (optional, but it makes connecting way easier to remember!). I personnaly recommend using hostinger as vps provider. Solid machines, no problems whatsoever after more than a year using their services.\nHere are the steps Log in to Your Coolify Dashboard Just open your web browser and go to your Coolify instance\u0026rsquo;s URL (like http://your-server-ip:8000). Pop in your admin details and you\u0026rsquo;re in !\nCreate a New Project (please stay organized.) In Coolify, projects help you organize your stuff. Click on \u0026ldquo;Projects\u0026rdquo; in the sidebar, then \u0026ldquo;Add New Project.\u0026rdquo; Give it a name, then create it and select the production environment.\nAdd a New Resource Head over to your new project (or the default one if you skipped the last step). Click \u0026ldquo;Add New Resource.\u0026rdquo; Choose \u0026ldquo;Service\u0026rdquo; and search for \u0026ldquo;Minecraft\u0026rdquo; !\nConfigure Environment Variables Minecraft servers need a few specific settings to work right. Under the \u0026ldquo;Environment Variables\u0026rdquo; section, you\u0026rsquo;ll add these:\nEULA: Add this one and set it to true. This automatically accepts the Minecraft End User License Agreement when the server starts up. MINECRAFT_MAX_MEMORY: Decide how much RAM you want to give your server, e.g., 2G for 2 Gigabytes. Adjust this based on your server\u0026rsquo;s power and how many friends will be joining! MINECRAFT_VERSION: Pick the exact Minecraft version you want, like 1.21.1. You can even add other variables here to tweak server properties, and potentially setup mods if you want to. Check the docs ! Set Up Persistent Storage This step is SUPER important! You definitely want your Minecraft world data (all your builds, player progress, everything!) to stick around even if the server restarts or updates. Under the \u0026ldquo;Volumes\u0026rdquo; section, add a new volume.\nWait\u0026hellip; Actually Coolify already made the volumes for us. Nothing to do here !\nConfigure Ports Minecraft servers usually uses port 25565. I would not recommend changing this if you\u0026rsquo;re not used to configuring port mapping.\nAssign a Domain (Optional, but way easier to remember): Under the \u0026ldquo;General \u0026gt; Services\u0026rdquo; section, you can add your own custom domain or a subdomain (like minecraft.yourdomain.com). Coolify will automatically handle the SSL certificate for this domain, keeping it secure and making it super easy for players to remember how to join. If you don\u0026rsquo;t have a domain, no worries, players can still connect using your server\u0026rsquo;s IP address and port.\nDeploy Your Minecraft Server Once everything looks good, hit that \u0026ldquo;Deploy\u0026rdquo; button! Coolify will then handle everything: pulling the Docker image, setting up the container with all your chosen settings, and firing up the Minecraft server. You can even watch the deployment logs right there in the Coolify dashboard.\nConnect to Your Server (Time to Play!) After a successful deployment, your Minecraft server will be live! Your friends can connect using your fancy domain (e.g., minecraft.yourdomain.com) or your server\u0026rsquo;s IP address followed by the port (e.g., your-server-ip:25565).\n"}]